#!/bin/bash
# USAGE
# fit2mp4 <file> <size> [opts for ffmpeg...]
# Example scaling: -vf scale=iw*.5:ih*.5 (iw, ih are original, understood by ffmpeg)

# -c:a copy might be interesting but tends to fail depending on source

# for h264/5:
# ultrafast,superfast,veryfast,faster,fast,medium,slow,slower,veryslow,placebo
# crf 18 is considered visually lossless, default is 23, range is 0-51 (0=lossless)
# for losless, -qp 0 is preferred over -crf
# medium speed is default, slower is better
# consider -tune film, animation, grain, stillimage, psnr, ssim, fastdecode, zerolatency 
#  for specific cases

set -o errexit
set -o nounset

lo=0
hi=51
best=51

codec=libx264
# Other choices: libx264 libx265
# For AV1 or webm (VP9) the command line options have to be adjusted

#extra="-movflags +faststart -pix_fmt yuv420p"
extra=
# allows to play an incomplete video
# and better compatibility with non-ffmpeg players
# something breaks with above flags

[ "${1:-}" == "" ] && { echo Missing source;      exit 1; }
[ "${2:-}" == "" ] && { echo Missing target size; exit 1; }

src="$1"
target=`echo $2 | numfmt --from=iec --to=none`

shift
shift

while true; do
	mid=$(( ($hi+$lo)/2 ))
	dst="${src%.*}.$mid.mp4"

	echo -n Encoding at quality "$lo [${mid}] $hi... "
	ffmpeg -loglevel warning -y -i "$src" -threads 8 -fs $target -strict -2 -c:v $codec -crf $mid -preset slow $extra "$@" "$dst"
	size=`stat --printf="%s" "$dst"`

	if [ $size -gt $target ]; then
		lo=$(( $mid + 1))
		echo Too big at `date`
	else
		hi=$(( $mid - 1 ))
		best=$mid
		echo OK at `date`
	fi

	if [ $lo -gt $hi ]; then
		echo Done at quality $best
		exit 0
	fi
done
